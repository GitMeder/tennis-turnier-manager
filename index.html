<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Tennis Turnier Manager</title>
  <style>
    :root {
      --bg: #f5f7fb;
      --surface: #ffffff;
      --primary: #2563eb;
      --primary-strong: #1d4ed8;
      --primary-soft: rgba(37, 99, 235, 0.1);
      --text: #0f172a;
      --text-muted: #475569;
      --border: rgba(15, 23, 42, 0.08);
      --radius-lg: 20px;
      --radius-md: 14px;
      --radius-sm: 10px;
      --shadow: 0 24px 70px -40px rgba(15, 23, 42, 0.4);
      --transition: 200ms ease;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(160deg, #eef2ff 0%, #f8fafc 45%, #e0e7ff 100%);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.6;
    }

    header {
      padding: 3rem 1.5rem 2rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2.2rem, 3vw, 2.8rem);
      letter-spacing: -0.02em;
    }

    header p {
      margin: 0.85rem auto 0;
      max-width: 680px;
      color: var(--text-muted);
      font-size: 1rem;
    }

    main {
      max-width: 1200px;
      margin: 0 auto 3rem;
      padding: 0 1.75rem 3rem;
      display: grid;
      gap: 1.6rem;
      grid-template-columns: minmax(0, 1fr);
      grid-template-areas:
        "players"
        "controls"
        "matches"
        "standings"
        "history";
    }

    .card {
      background: var(--surface);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 1.8rem;
      display: grid;
      gap: 1.2rem;
      transition: transform var(--transition), box-shadow var(--transition);
    }

    @media (hover: hover) and (pointer: fine) {
      .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 34px 80px -45px rgba(15, 23, 42, 0.5);
      }
    }

    .card--players { grid-area: players; }
    .card--controls { grid-area: controls; align-self: start; display: grid; gap: 1.1rem; grid-auto-rows: min-content; }
    .card--matches {
      grid-area: matches;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 1.2rem;
    }
    .card--standings { grid-area: standings; }
    .card--history { grid-area: history; }

    h2 {
      margin: 0;
      font-size: 1.4rem;
      letter-spacing: -0.01em;
    }

    form {
      margin: 0;
    }

    .player-form {
      display: grid;
      gap: 0.8rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .player-form .field-group {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    input[type="text"] {
      width: 100%;
      padding: 0.75rem 1rem;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(248, 250, 252, 0.85);
      font-size: 1rem;
      transition: border-color var(--transition), box-shadow var(--transition), background var(--transition);
    }

    input[type="text"]:focus-visible {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px var(--primary-soft);
      background: #fff;
    }

    label.checkbox {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--text-muted);
      cursor: pointer;
      user-select: none;
    }

    button {
      cursor: pointer;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.75rem 1.3rem;
      font-size: 1rem;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-strong) 100%);
      box-shadow: 0 18px 45px -28px rgba(37, 99, 235, 0.65);
      transition: transform 160ms ease, box-shadow 200ms ease, filter 160ms ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
    }

    button.secondary {
      background: rgba(37, 99, 235, 0.15);
      color: var(--primary);
      box-shadow: none;
      border: 1px solid rgba(37, 99, 235, 0.25);
    }

    button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px var(--primary-soft);
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 22px 52px -26px rgba(37, 99, 235, 0.75);
      filter: brightness(1.03);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      box-shadow: none;
    }

    .player-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.75rem;
    }

    .player-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.8rem 1rem;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.85);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }

    .player-meta {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background: var(--primary-soft);
      color: var(--primary);
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .action-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
    }

    .action-bar button {
      flex: 1 1 200px;
    }

    .status {
      margin: 0;
      font-weight: 600;
      color: var(--text);
      background: rgba(37, 99, 235, 0.1);
      padding: 0.7rem 1rem;
      border-radius: var(--radius-md);
      border: 1px solid rgba(37, 99, 235, 0.2);
    }

    .matches {
      display: grid;
      gap: 1.2rem;
      margin: 0;
      align-content: start;
    }

    .option {
      display: grid;
      gap: 0.45rem;
    }

    .option label {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.45rem 0.65rem;
      border-radius: var(--radius-sm);
      border: 1px solid transparent;
      transition: border-color var(--transition), background var(--transition);
    }

    .option label:hover,
    .option label:focus-within {
      border-color: rgba(37, 99, 235, 0.25);
      background: rgba(37, 99, 235, 0.08);
    }

    .option input[type="radio"] {
      accent-color: var(--primary);
    }

    fieldset.match {
      margin: 0;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: var(--radius-lg);
      padding: 1.2rem 1.5rem;
      background: rgba(255, 255, 255, 0.88);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      display: grid;
      gap: 0.9rem;
      animation: fadeInUp 320ms ease both;
    }

    fieldset.match legend {
      font-weight: 700;
      color: var(--primary-strong);
      letter-spacing: 0.02em;
      padding: 0 0.3rem;
    }

    .empty-state {
      text-align: center;
      padding: 2rem 1.5rem;
      border-radius: var(--radius-md);
      border: 1px dashed rgba(148, 163, 184, 0.3);
      background: rgba(248, 250, 252, 0.7);
      color: var(--text-muted);
      font-size: 0.95rem;
      display: grid;
      gap: 0.4rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      border-radius: var(--radius-lg);
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    thead {
      background: rgba(37, 99, 235, 0.12);
      color: var(--primary-strong);
    }

    th, td {
      padding: 0.8rem 1rem;
      text-align: left;
      font-size: 0.95rem;
    }

    tbody tr:nth-child(odd) {
      background: rgba(248, 250, 252, 0.92);
    }

    tbody tr:nth-child(even) {
      background: rgba(255, 255, 255, 0.85);
    }

    tbody tr + tr {
      border-top: 1px solid rgba(148, 163, 184, 0.2);
    }

    .history {
      display: grid;
      gap: 1rem;
    }

    .history-round {
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: var(--radius-lg);
      padding: 1.2rem 1.4rem;
      background: rgba(255, 255, 255, 0.9);
      display: grid;
      gap: 0.75rem;
    }

    .history-round h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .history-match {
      border-radius: var(--radius-md);
      background: rgba(15, 23, 42, 0.03);
      border: 1px solid rgba(148, 163, 184, 0.2);
      padding: 0.75rem 0.9rem;
      display: grid;
      gap: 0.4rem;
    }

    .bye {
      font-style: italic;
      color: #0f766e;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (min-width: 800px) {
      main {
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        grid-template-areas:
          "players controls"
          "matches matches"
          "standings standings"
          "history history";
      }
    }

    @media (min-width: 1100px) {
      main {
        grid-template-columns: minmax(260px, 1fr) minmax(260px, 1fr) minmax(340px, 1.2fr);
        grid-template-areas:
          "players controls matches"
          "standings standings matches"
          "history history matches";
      }
    }

    @media (max-width: 720px) {
      header {
        padding: 2.4rem 1.1rem 1.8rem;
      }

      main {
        padding: 0 1rem 2.2rem;
        gap: 1.2rem;
      }

      .card {
        padding: 1.4rem 1.2rem;
      }

      .player-form {
        grid-template-columns: 1fr;
      }

      .action-bar {
        flex-direction: column;
        gap: 0.6rem;
      }

      .action-bar button {
        flex: 1 1 auto;
        width: 100%;
        min-width: 0;
      }

      button {
        width: 100%;
      }

      .matches {
        gap: 1rem;
      }

      fieldset.match {
        padding: 1rem 1rem 1.1rem;
      }

      .history-match {
        padding: 0.65rem 0.75rem;
      }
    }

    @media (max-width: 540px) {
      header h1 {
        font-size: clamp(1.9rem, 8vw, 2.2rem);
      }

      header p {
        font-size: 0.95rem;
      }

      h2 {
        font-size: 1.2rem;
      }

      input[type="text"] {
        padding: 0.65rem 0.75rem;
        font-size: 0.95rem;
      }

    }
  </style>
</head>
<body>
  <header>
    <h1>Tennis Turnier Manager</h1>
    <p>Verwalte beliebig viele Runden, markiere gesetzte Spieler, erfasse Ergebnisse und behalte mit der Rangliste jederzeit den Überblick.</p>
  </header>

  <main>
    <section class="card card--players">
      <h2>Spieler hinzufügen</h2>
      <form id="playerForm" class="player-form">
        <input id="playerInput" type="text" placeholder="Name des Spielers" autocomplete="off" required>
        <div class="field-group">
          <label class="checkbox">
            <input id="seededInput" type="checkbox">
            gesetzt
          </label>
        </div>
        <button type="submit">Hinzufügen</button>
      </form>
      <ul id="playerList" class="player-list"></ul>
    </section>

    <section class="card card--controls">
      <h2>Rundensteuerung</h2>
      <p id="roundInfo" class="status">Aktive Spieler: 0</p>
      <div class="action-bar">
        <button id="generateRoundBtn" disabled>Neue Runde erstellen</button>
        <button id="resetBtn" class="secondary">Turnier zurücksetzen</button>
      </div>
    </section>

    <section class="card card--matches">
      <h2>Aktuelle Runde</h2>
      <form id="matchesForm">
        <div id="matchesContainer" class="matches">
          <div class="empty-state">
            <strong>Noch keine Runde gestartet</strong>
            <span>Klicke auf „Neue Runde erstellen“, um Begegnungen zu generieren.</span>
          </div>
        </div>
        <div class="action-bar" id="submitWrapper" style="display:none;">
          <button type="submit">Ergebnisse übernehmen</button>
        </div>
      </form>
    </section>

    <section class="card card--standings">
      <h2>Rangliste</h2>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th>Spieler</th>
              <th>Punkte</th>
              <th>Gewonnen</th>
              <th>Verloren</th>
              <th>Spieldifferenz</th>
            </tr>
          </thead>
          <tbody id="standingsBody">
            <tr>
              <td colspan="5" style="text-align:center; color: var(--text-muted); padding: 1.2rem;">
                Füge Spieler hinzu und starte eine Runde, um die Rangliste zu sehen.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <section class="card card--history">
      <h2>Historie</h2>
      <div id="history" class="history">
        <div class="empty-state">
          <strong>Noch keine Runden gespielt</strong>
          <span>Ergebnisse werden hier protokolliert, sobald du eine Runde abschließt.</span>
        </div>
      </div>
    </section>
  </main>

  <script>
    const state = {
      players: [],
      nextId: 1,
      currentRound: null,
      history: [],
      pairCounts: new Map()
    };

    const playerForm = document.getElementById('playerForm');
    const playerInput = document.getElementById('playerInput');
    const seededInput = document.getElementById('seededInput');
    const playerList = document.getElementById('playerList');

    const roundInfo = document.getElementById('roundInfo');
    const generateRoundBtn = document.getElementById('generateRoundBtn');
    const resetBtn = document.getElementById('resetBtn');

    const matchesForm = document.getElementById('matchesForm');
    const matchesContainer = document.getElementById('matchesContainer');
    const submitWrapper = document.getElementById('submitWrapper');

    const standingsBody = document.getElementById('standingsBody');
    const historyContainer = document.getElementById('history');

    const shuffle = (array) => {
      const copy = [...array];
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    };

    const getPairKey = (seededId, unseededId) => `${seededId}|${unseededId}`;

    const getPairCount = (seededId, unseededId, source = state.pairCounts) => {
      if (!seededId || !unseededId) return 0;
      const key = getPairKey(seededId, unseededId);
      return source.get(key) || 0;
    };

    const incrementPairCount = (seededId, unseededId, target = state.pairCounts) => {
      if (!seededId || !unseededId) return;
      const key = getPairKey(seededId, unseededId);
      target.set(key, (target.get(key) || 0) + 1);
    };

    const createPlayer = (name, seeded) => ({
      id: state.nextId++,
      name,
      seeded,
      stats: {
        points: 0,
        wins: 0,
        losses: 0,
        draws: 0
      }
    });

    const formatDiff = (player) => player.stats.wins - player.stats.losses;

    const renderPlayers = () => {
      playerList.innerHTML = '';
      if (!state.players.length) {
        const empty = document.createElement('li');
        empty.className = 'player-item';
        empty.style.justifyContent = 'center';
        empty.style.color = 'var(--text-muted)';
        empty.textContent = 'Noch keine Spieler hinzugefügt.';
        playerList.appendChild(empty);
        return;
      }

      state.players.forEach((player) => {
        const li = document.createElement('li');
        li.className = 'player-item';

        const left = document.createElement('div');
        left.className = 'player-meta';
        const nameSpan = document.createElement('span');
        nameSpan.textContent = player.name;
        left.appendChild(nameSpan);

        if (player.seeded) {
          const badge = document.createElement('span');
          badge.className = 'tag';
          badge.textContent = 'gesetzt';
          left.appendChild(badge);
        }

        li.appendChild(left);

        if (!state.history.length && !state.currentRound) {
          const removeBtn = document.createElement('button');
          removeBtn.className = 'secondary';
          removeBtn.textContent = 'Entfernen';
          removeBtn.addEventListener('click', () => {
            state.players = state.players.filter((p) => p.id !== player.id);
            renderPlayers();
            updateControls();
            renderStandings();
          });
          li.appendChild(removeBtn);
        }

        playerList.appendChild(li);
      });
    };

    const updateControls = () => {
      const seededCount = state.players.filter((p) => p.seeded).length;
      const unseededCount = state.players.length - seededCount;
      roundInfo.textContent = `Aktive Spieler: ${state.players.length} – gesetzt: ${seededCount}, ungesetzt: ${unseededCount}`;
      const canGenerate = state.players.length >= 4 && seededCount > 0 && unseededCount > 0;
      generateRoundBtn.disabled = !canGenerate || !!state.currentRound;
    };


    const renderMatches = () => {
      matchesContainer.innerHTML = '';

      if (!state.currentRound) {
        matchesContainer.innerHTML = `
          <div class="empty-state">
            <strong>Noch keine Runde gestartet</strong>
            <span>Klicke auf „Neue Runde erstellen“, um Begegnungen zu generieren.</span>
          </div>
        `;
        submitWrapper.style.display = 'none';
        return;
      }

      const { matches, byes } = state.currentRound;

      matches.forEach((match) => {
        const fieldset = document.createElement('fieldset');
        fieldset.className = 'match';

        const teamASeeded = state.players.find((p) => p.id === match.teamA.seededId);
        const teamAUnseeded = state.players.find((p) => p.id === match.teamA.unseededId);
        const teamBSeeded = state.players.find((p) => p.id === match.teamB.seededId);
        const teamBUnseeded = state.players.find((p) => p.id === match.teamB.unseededId);

        if (!teamASeeded || !teamAUnseeded || !teamBSeeded || !teamBUnseeded) {
          return;
        }

        const legend = document.createElement('legend');
        legend.textContent = `${teamASeeded.name} & ${teamAUnseeded.name} vs. ${teamBSeeded.name} & ${teamBUnseeded.name}`;
        fieldset.appendChild(legend);

        const optionWrapper = document.createElement('div');
        optionWrapper.className = 'option';

        const options = [
          { value: 'A', label: `${teamASeeded.name} & ${teamAUnseeded.name} gewinnen` },
          { value: 'DRAW', label: 'Unentschieden' },
          { value: 'B', label: `${teamBSeeded.name} & ${teamBUnseeded.name} gewinnen` }
        ];

        options.forEach((option) => {
          const label = document.createElement('label');
          const radio = document.createElement('input');
          radio.type = 'radio';
          radio.name = `match-${match.id}`;
          radio.value = option.value;
          label.appendChild(radio);
          label.append(option.label);
          optionWrapper.appendChild(label);
        });
        fieldset.appendChild(optionWrapper);

        matchesContainer.appendChild(fieldset);
      });

      if (byes.length) {
        const byeCard = document.createElement('fieldset');
        byeCard.className = 'match';
        const legend = document.createElement('legend');
        legend.textContent = 'Freilose';
        byeCard.appendChild(legend);

        const info = document.createElement('p');
        info.className = 'bye';
        const names = byes.map((b) => b.name).join(', ');
        info.textContent = `${names} ${byes.length === 1 ? 'erhält' : 'erhalten'} in dieser Runde automatisch 2 Punkte.`;
        byeCard.appendChild(info);
        matchesContainer.appendChild(byeCard);
      }

      submitWrapper.style.display = matches.length ? 'flex' : 'none';
    };

    const renderStandings = () => {
      if (!state.players.length) {
        standingsBody.innerHTML = `
          <tr>
            <td colspan="5" style="text-align:center; color: var(--text-muted); padding: 1.2rem;">
              Füge Spieler hinzu und starte eine Runde, um die Rangliste zu sehen.
            </td>
          </tr>
        `;
        return;
      }

      const sorted = [...state.players].sort((a, b) => {
        if (b.stats.points !== a.stats.points) return b.stats.points - a.stats.points;
        const diffB = formatDiff(b);
        const diffA = formatDiff(a);
        if (diffB !== diffA) return diffB - diffA;
        if (b.stats.wins !== a.stats.wins) return b.stats.wins - a.stats.wins;
        return a.name.localeCompare(b.name, 'de');
      });

      standingsBody.innerHTML = '';

      sorted.forEach((player) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${player.name}${player.seeded ? ' <span class="tag" style="margin-left:6px;">gesetzt</span>' : ''}</td>
          <td>${player.stats.points}</td>
          <td>${player.stats.wins}</td>
          <td>${player.stats.losses}</td>
          <td>${formatDiff(player)}</td>
        `;
        standingsBody.appendChild(tr);
      });
    };

    const renderHistory = () => {
      historyContainer.innerHTML = '';
      if (!state.history.length) {
        historyContainer.innerHTML = `
          <div class="empty-state">
            <strong>Noch keine Runden gespielt</strong>
            <span>Ergebnisse werden hier protokolliert, sobald du eine Runde abschließt.</span>
          </div>
        `;
        return;
      }

      state.history.slice().reverse().forEach((round) => {
        const roundCard = document.createElement('div');
        roundCard.className = 'history-round';
        const title = document.createElement('h3');
        title.textContent = `Runde ${round.number}`;
        roundCard.appendChild(title);

        round.matches.forEach((match, index) => {
          const block = document.createElement('div');
          block.className = 'history-match';

          const vs = document.createElement('p');
          const teamAText = match.teamA.join(' & ');
          const teamBText = match.teamB.join(' & ');
          vs.innerHTML = `<strong>Match ${index + 1}:</strong> ${teamAText} gegen ${teamBText}`;
          block.appendChild(vs);

          const result = document.createElement('p');
          result.innerHTML = match.resultText;
          block.appendChild(result);

          roundCard.appendChild(block);
        });

        if (round.byes.length) {
          const bye = document.createElement('p');
          bye.className = 'bye';
          bye.textContent = `${round.byes.join(', ')} erhielten ein Freilos (+2 Punkte).`;
          roundCard.appendChild(bye);
        }

        historyContainer.appendChild(roundCard);
      });
    };

    const generateRound = () => {
      if (state.currentRound) {
        alert('Bitte beende zuerst die aktuelle Runde.');
        return;
      }
      if (state.players.length < 4) {
        alert('Für Doppel werden mindestens vier Spieler (jeweils gesetzt und ungesetzt) benötigt.');
        return;
      }

      const seededPool = shuffle(state.players.filter((p) => p.seeded));
      const unseededPool = shuffle(state.players.filter((p) => !p.seeded));

      if (!seededPool.length || !unseededPool.length) {
        alert('Es werden sowohl gesetzte als auch ungesetzte Spieler benötigt, um eine Doppelrunde zu erstellen.');
        return;
      }

      const tempCounts = new Map(state.pairCounts);
      const teams = [];
      const byes = [];

      while (seededPool.length && unseededPool.length) {
        const seeded = seededPool.shift();
        let bestIndex = 0;
        let bestScore = Number.POSITIVE_INFINITY;

        unseededPool.forEach((candidate, idx) => {
          const score = getPairCount(seeded.id, candidate.id, tempCounts);
          if (score < bestScore || (score === bestScore && Math.random() > 0.5)) {
            bestScore = score;
            bestIndex = idx;
          }
        });

        const partner = unseededPool.splice(bestIndex, 1)[0];
        teams.push({ seededId: seeded.id, unseededId: partner.id });
        incrementPairCount(seeded.id, partner.id, tempCounts);
      }

      // verbleibende Spieler erhalten Freilos (keine gemischten Teams mehr möglich)
      seededPool.forEach((player) => byes.push(player));
      unseededPool.forEach((player) => byes.push(player));

      if (!teams.length) {
        alert('Es konnten keine gemischten Doppel-Teams gebildet werden. Füge weitere Spieler hinzu.');
        return;
      }

      const teamOrder = shuffle(teams);
      const matches = [];

      for (let i = 0; i + 1 < teamOrder.length; i += 2) {
        const teamA = teamOrder[i];
        const teamB = teamOrder[i + 1];
        matches.push({
          id: `${state.history.length + 1}-${matches.length + 1}`,
          teamA,
          teamB
        });
      }

      if (teamOrder.length % 2 === 1) {
        const leftoverTeam = teamOrder[teamOrder.length - 1];
        const leftoverPlayers = [
          state.players.find((p) => p.id === leftoverTeam.seededId),
          state.players.find((p) => p.id === leftoverTeam.unseededId)
        ].filter(Boolean);
        byes.push(...leftoverPlayers);
      }

      if (!matches.length && byes.length) {
        alert('Durch die aktuelle Konstellation entsteht nur ein Freilos. Füge weitere Spieler hinzu.');
        return;
      }

      state.currentRound = {
        number: state.history.length + 1,
        matches,
        byes
      };

      renderMatches();
      updateControls();
    };

    const applyResult = (player, outcome) => {
      if (outcome === 'WIN') {
        player.stats.points += 2;
        player.stats.wins += 1;
      } else if (outcome === 'LOSS') {
        player.stats.losses += 1;
      } else if (outcome === 'DRAW') {
        player.stats.points += 1;
        player.stats.draws += 1;
      } else if (outcome === 'BYE') {
        player.stats.points += 2;
      }
    };

    const processResults = (event) => {
      event.preventDefault();
      if (!state.currentRound) {
        return;
      }

      const { matches, byes, number } = state.currentRound;

      const roundRecord = {
        number,
        matches: [],
        byes: byes.map((player) => player.name)
      };

      for (const match of matches) {
        const result = matchesForm.querySelector(`input[name="match-${match.id}"]:checked`);
        if (!result) {
          alert('Bitte trage für jedes Match ein Ergebnis ein.');
          return;
        }

        const teamAPlayers = [
          state.players.find((p) => p.id === match.teamA.seededId),
          state.players.find((p) => p.id === match.teamA.unseededId)
        ].filter(Boolean);
        const teamBPlayers = [
          state.players.find((p) => p.id === match.teamB.seededId),
          state.players.find((p) => p.id === match.teamB.unseededId)
        ].filter(Boolean);

        if (teamAPlayers.length !== 2 || teamBPlayers.length !== 2) {
          continue;
        }

        let resultText = '';

        if (result.value === 'A') {
          teamAPlayers.forEach((player) => applyResult(player, 'WIN'));
          teamBPlayers.forEach((player) => applyResult(player, 'LOSS'));
          resultText = `<span class="tag">Sieger: ${teamAPlayers[0].name} & ${teamAPlayers[1].name}</span>`;
        } else if (result.value === 'B') {
          teamBPlayers.forEach((player) => applyResult(player, 'WIN'));
          teamAPlayers.forEach((player) => applyResult(player, 'LOSS'));
          resultText = `<span class="tag">Sieger: ${teamBPlayers[0].name} & ${teamBPlayers[1].name}</span>`;
        } else {
          teamAPlayers.forEach((player) => applyResult(player, 'DRAW'));
          teamBPlayers.forEach((player) => applyResult(player, 'DRAW'));
          resultText = `<span class="tag" style="background: rgba(249, 115, 22, 0.15); color:#c2410c;">Unentschieden</span>`;
        }

        incrementPairCount(match.teamA.seededId, match.teamA.unseededId);
        incrementPairCount(match.teamB.seededId, match.teamB.unseededId);

        roundRecord.matches.push({
          teamA: teamAPlayers.map((player) => player.name),
          teamB: teamBPlayers.map((player) => player.name),
          resultText
        });
      }

      byes.forEach((player) => {
        applyResult(player, 'BYE');
      });

      state.history.push(roundRecord);
      state.currentRound = null;

      matchesForm.reset();
      renderMatches();
      renderStandings();
      renderHistory();
      updateControls();
    };

    const resetTournament = () => {
      if (!confirm('Turnier wirklich zurücksetzen?')) {
        return;
      }
      state.players = [];
      state.nextId = 1;
      state.currentRound = null;
      state.history = [];
      state.pairCounts = new Map();
      playerForm.reset();
      renderPlayers();
      renderMatches();
      renderStandings();
      renderHistory();
      updateControls();
    };

    playerForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const name = playerInput.value.trim();
      const seeded = seededInput.checked;
      if (!name) return;

      state.players.push(createPlayer(name, seeded));
      playerInput.value = '';
      seededInput.checked = false;
      renderPlayers();
      renderStandings();
      updateControls();
    });

    generateRoundBtn.addEventListener('click', generateRound);
    matchesForm.addEventListener('submit', processResults);
    resetBtn.addEventListener('click', resetTournament);

    renderPlayers();
    updateControls();
    renderStandings();
    renderHistory();
  </script>
</body>
</html>
