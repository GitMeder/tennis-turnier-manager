<!DOCTYPE html>
<html lang="de">

<head>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0C6CF2" charset="UTF-8">
  <link rel="icon" href="icon-192.png">
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js');
      });
    }
  </script>
  <title>Tennis Turnier Manager</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #eef2ff 0%, #f8fafc 55%, #e2e8f0 100%);
      --surface: rgba(255, 255, 255, 0.94);
      --surface-soft: rgba(255, 255, 255, 0.75);
      --primary: #2563eb;
      --primary-strong: #1d4ed8;
      --primary-soft: rgba(37, 99, 235, 0.12);
      --text: #0f172a;
      --text-muted: #475569;
      --border: rgba(148, 163, 184, 0.35);
      --border-strong: rgba(37, 99, 235, 0.35);
      --radius-lg: 22px;
      --radius-md: 14px;
      --radius-sm: 10px;
      --shadow-lg: 0 32px 80px -40px rgba(15, 23, 42, 0.45);
      --shadow-sm: 0 18px 50px -30px rgba(15, 23, 42, 0.35);
      --transition: 220ms ease;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.6;
    }

    header {
      padding: 3rem 1.5rem 2.5rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2.2rem, 3.2vw, 2.9rem);
      letter-spacing: -0.03em;
    }

    header p {
      max-width: 640px;
      margin: 0.75rem auto 0;
      color: var(--text-muted);
      font-size: 1rem;
    }

    main {
      max-width: 1160px;
      margin: 0 auto 3rem;
      padding: 0 1.75rem 3rem;
      display: grid;
      gap: 1.6rem;
      grid-template-columns: minmax(0, 1fr);
      grid-template-areas:
        "players"
        "controls"
        "matches"
        "history";
    }

    section {
      background: var(--surface);
      backdrop-filter: blur(14px);
      border-radius: var(--radius-lg);
      padding: 1.9rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg);
      display: grid;
      gap: 1.2rem;
      transition: transform 240ms ease, box-shadow 320ms ease;
    }

  @media (hover: hover) and (pointer: fine) {
    section:hover {
      transform: translateY(-2px);
      box-shadow: 0 38px 90px -40px rgba(15, 23, 42, 0.4);
    }
  }

    .card--players {
      grid-area: players;
    }

    .card--controls {
      grid-area: controls;
      align-self: start;
      display: grid;
      gap: 1rem;
      grid-auto-rows: min-content;
    }

    .card--matches {
      grid-area: matches;
      align-self: start;
      gap: 1.4rem;
    }

    .card--history {
      grid-area: history;
    }

    h2 {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: -0.01em;
    }

    form {
      margin: 0;
    }

    .player-form {
      display: flex;
      gap: 0.8rem;
      flex-wrap: wrap;
    }

    input[type="text"] {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      background: var(--surface-soft);
      color: var(--text);
      transition: border-color var(--transition), box-shadow var(--transition), background var(--transition);
      box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.04);
    }

    input[type="text"]:focus-visible {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px var(--primary-soft);
      background: #fff;
    }

    button {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.72rem 1.2rem;
      font-size: 0.98rem;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-strong) 100%);
      box-shadow: var(--shadow-sm);
      transition: transform 180ms ease, box-shadow 200ms ease, filter 180ms ease;
    }

    button.secondary {
      background: rgba(37, 99, 235, 0.08);
      color: var(--primary);
      box-shadow: none;
      border: 1px solid rgba(37, 99, 235, 0.25);
    }

    button.small {
      padding: 0.45rem 0.9rem;
      font-size: 0.85rem;
      border-radius: var(--radius-sm);
    }

    button.small.secondary {
      border-color: rgba(37, 99, 235, 0.2);
      background: rgba(37, 99, 235, 0.1);
    }

    button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px var(--primary-soft);
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px -20px rgba(37, 99, 235, 0.65);
      filter: brightness(1.03);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      filter: brightness(0.97);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      box-shadow: none;
    }

    ul.player-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.7rem;
    }

    ul.player-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      border-radius: var(--radius-md);
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45);
      transition: transform 150ms ease, box-shadow 220ms ease;
    }

    ul.player-list li:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 36px -28px rgba(15, 23, 42, 0.55);
    }

    ul.player-list li span.label {
      font-weight: 600;
      font-size: 0.98rem;
    }

    .tag,
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      gap: 0.35rem;
    }

    .tag {
      background: var(--primary-soft);
      color: var(--primary);
    }

    .badge.stage {
      background: rgba(22, 163, 74, 0.12);
      color: #166534;
    }

    .badge.placement {
      background: rgba(2, 132, 199, 0.12);
      color: #0c4a6e;
    }

    .match-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.6rem;
      align-items: center;
    }

    .mode-toggle {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .mode-toggle label {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem 1rem;
      border-radius: var(--radius-md);
      border: 1px solid transparent;
      color: var(--text-muted);
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.75);
      transition: border-color var(--transition), color var(--transition), box-shadow var(--transition), background var(--transition);
    }

    .mode-toggle input {
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
    }

    .mode-toggle label.active {
      border-color: var(--border-strong);
      background: var(--primary-soft);
      color: var(--primary-strong);
      box-shadow: 0 12px 30px -24px rgba(37, 99, 235, 0.65);
    }

    .mode-toggle label.disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .status {
      font-weight: 600;
      color: var(--text);
      background: rgba(37, 99, 235, 0.08);
      padding: 0.65rem 0.9rem;
      border-radius: var(--radius-md);
      border: 1px solid rgba(37, 99, 235, 0.2);
    }

    .action-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
    }

    .action-bar button {
      flex: 1 1 auto;
      min-width: 140px;
    }

    #byeInfo p {
      margin: 0;
      padding: 0.8rem;
      border-radius: var(--radius-md);
      background: rgba(15, 118, 110, 0.08);
      color: #0f766e;
      border: 1px solid rgba(15, 118, 110, 0.2);
    }

    #byeInfo strong {
      font-weight: 700;
    }

    #matchesForm {
      display: grid;
      gap: 1.2rem;
    }

    .matches {
      display: grid;
      gap: 1.2rem;
    }

    .bye-info:empty {
      display: none;
    }

    .submit-area {
      display: none;
      flex-wrap: wrap;
      gap: 0.8rem;
      justify-content: flex-end;
      margin-top: 0.6rem;
      padding-top: 0.4rem;
    }

    .empty-state {
      display: grid;
      place-items: center;
      text-align: center;
      padding: 2rem 1.5rem;
      border-radius: var(--radius-md);
      border: 1px dashed rgba(148, 163, 184, 0.4);
      color: var(--text-muted);
      background: rgba(248, 250, 252, 0.7);
      font-size: 0.95rem;
      gap: 0.35rem;
    }

    .empty-state strong {
      color: var(--text);
      font-weight: 700;
    }

    fieldset.match {
      margin: 0;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      padding: 1.2rem 1.4rem;
      background: rgba(255, 255, 255, 0.85);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5), 0 24px 50px -36px rgba(15, 23, 42, 0.55);
      animation: fadeInUp 420ms ease both;
    }

    fieldset.match legend {
      font-weight: 700;
      font-size: 0.95rem;
      letter-spacing: 0.01em;
      color: var(--primary-strong);
    }

    .option {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      padding: 0.35rem 0;
      color: var(--text);
      font-weight: 500;
    }

    .option input[type="radio"] {
      width: 1rem;
      height: 1rem;
      accent-color: var(--primary);
    }

    .score-input {
      margin-top: 0.9rem;
      display: grid;
      gap: 0.35rem;
    }

    .score-input label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-muted);
    }

    .score-input input {
      padding: 0.65rem 0.9rem;
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      background: rgba(248, 250, 252, 0.9);
    }

    .timer {
      margin-top: 0.75rem;
      padding: 0.75rem 0.9rem;
      border-radius: var(--radius-md);
      background: rgba(37, 99, 235, 0.05);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.7rem;
      border: 1px solid rgba(37, 99, 235, 0.18);
    }

    .timer-display {
      font-family: "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--primary-strong);
      min-width: 8.5ch;
    }

    .timer-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .history {
      display: grid;
      gap: 1.1rem;
    }

    .history-round {
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      padding: 1.2rem 1.4rem;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }

    .history-round h3 {
      margin: 0 0 0.6rem;
    }

    .history-round p {
      margin: 0.35rem 0;
      color: var(--text-muted);
      font-size: 0.96rem;
    }

    .history-round .tag {
      margin-top: 0.4rem;
      display: inline-flex;
    }

    .history-match {
      border-radius: var(--radius-md);
      background: rgba(15, 23, 42, 0.03);
      border: 1px solid rgba(148, 163, 184, 0.2);
      padding: 0.75rem 0.9rem;
      margin-bottom: 0.6rem;
      display: grid;
      gap: 0.4rem;
    }

    .bye {
      font-style: italic;
      color: #075985;
    }

    #champion {
      display: none;
    }

    #champion:not(:empty) {
      display: block;
      padding: 1.2rem 1.4rem;
      border-radius: var(--radius-lg);
      background: linear-gradient(135deg, rgba(250, 204, 21, 0.22), rgba(250, 204, 21, 0.06));
      border: 1px solid rgba(180, 137, 9, 0.25);
      box-shadow: 0 30px 70px -50px rgba(250, 204, 21, 0.8);
      animation: fadeInUp 480ms ease both;
    }

    #champion:not(:empty) h3 {
      margin: 0 0 0.4rem;
    }

    #champion:not(:empty) p {
      margin: 0;
      font-weight: 600;
      color: #b45309;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(8px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (min-width: 820px) {
      main {
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        grid-template-areas:
          "players controls"
          "matches matches"
          "history history";
      }
    }

    @media (min-width: 1040px) {
      main {
        grid-template-columns: minmax(260px, 1fr) minmax(260px, 1fr) minmax(320px, 1.1fr);
        grid-template-areas:
          "players controls matches"
          "history history matches";
      }
    }

  @media (max-width: 720px) {
    header {
      padding: 2.5rem 1.2rem 1.8rem;
    }

      main {
        padding: 0 1rem 2.4rem;
        gap: 1.2rem;
      }

      section {
        padding: 1.4rem;
      }

    .player-form {
      flex-direction: column;
      align-items: stretch;
    }

    .action-bar {
      flex-direction: column;
    }

    button {
      width: 100%;
      justify-content: center;
    }

    .timer {
      flex-direction: column;
      align-items: flex-start;
    }
  }

  @media (max-width: 540px) {
    header h1 {
      font-size: clamp(1.8rem, 8vw, 2.2rem);
    }

    header p {
      font-size: 0.92rem;
    }

    main {
      padding: 0 1rem 2rem;
      gap: 1rem;
    }

    section {
      padding: 1.2rem 1rem;
      border-radius: 18px;
      gap: 1rem;
    }

    h2 {
      font-size: 1.15rem;
    }

    input[type="text"] {
      padding: 0.65rem 0.8rem;
      font-size: 0.95rem;
    }

    .mode-toggle label {
      flex: 1 1 45%;
      justify-content: center;
      font-size: 0.85rem;
      padding: 0.45rem 0.75rem;
    }

    .action-bar {
      gap: 0.6rem;
    }

    .action-bar button {
      min-width: 0;
    }

    .matches {
      gap: 1rem;
    }

    fieldset.match {
      padding: 1rem;
    }

    .timer {
      width: 100%;
      align-items: stretch;
    }

    .timer-controls {
      width: 100%;
      justify-content: space-between;
    }

    .timer-controls button {
      flex: 1 1 48%;
      width: auto;
    }

    .history-match {
      padding: 0.65rem 0.75rem;
    }
  }

    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation-duration: 1ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 1ms !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>Tennis Turnier Manager</h1>
    <p>Erstelle zufällige Einzel- oder Doppelrunden, erfasse Ergebnisse und finde den Champion.</p>
  </header>

  <main>
    <section class="card card--players">
      <h2>Spieler hinzufügen</h2>
      <form class="player-form" id="playerForm">
        <input id="playerInput" type="text" placeholder="Name des Spielers" autocomplete="off" required>
        <button type="submit">Hinzufügen</button>
      </form>
      <ul class="player-list" id="playerList"></ul>
    </section>

    <section class="card card--controls">
      <h2>Rundenverwaltung</h2>
      <p class="status" id="roundStatus">Aktuelle Teilnehmer: 0</p>
      <div class="mode-toggle" id="modeToggle">
        <label class="active">
          <input type="radio" name="mode" value="singles" checked>
          Einzel
        </label>
        <label>
          <input type="radio" name="mode" value="doubles">
          Doppel
        </label>
      </div>
      <div class="action-bar">
        <button id="startRoundBtn">Neue Runde starten</button>
        <button id="resetBtn" class="secondary">Turnier zurücksetzen</button>
      </div>
      <div id="champion"></div>
    </section>

    <section class="card card--matches">
      <h2>Aktuelle Matches</h2>
      <div id="byeInfo" class="bye-info"></div>
      <form id="matchesForm">
        <div class="matches" id="matchesContainer"></div>
        <div class="submit-area" id="submitWrapper">
          <button type="submit">Ergebnisse übernehmen</button>
        </div>
      </form>
    </section>

    <section class="card card--history">
      <h2>Historie</h2>
      <div class="history" id="history"></div>
    </section>
  </main>

  <script>
    const state = {
      participants: [],
      currentRound: 0,
      matches: [],
      bye: [],
      history: [],
      mode: 'singles'
    };

    let nextId = 1;

    const playerForm = document.getElementById('playerForm');
    const playerInput = document.getElementById('playerInput');
    const playerList = document.getElementById('playerList');
    const startRoundBtn = document.getElementById('startRoundBtn');
    const resetBtn = document.getElementById('resetBtn');
    const roundStatus = document.getElementById('roundStatus');
    const modeToggle = document.getElementById('modeToggle');
    const matchesForm = document.getElementById('matchesForm');
    const matchesContainer = document.getElementById('matchesContainer');
    const submitWrapper = document.getElementById('submitWrapper');
    const historyContainer = document.getElementById('history');
    const byeInfo = document.getElementById('byeInfo');
    const champion = document.getElementById('champion');
    const modeInputs = modeToggle.querySelectorAll('input[name="mode"]');
    const matchTimers = new Map();

    const getStageInfo = (participantCount) => {
      if (participantCount <= 2) {
        return { stage: 'Finale', placement: 'Spiel um Platz 1' };
      }
      if (participantCount <= 4) {
        return { stage: 'Halbfinale', placement: 'Spiel um Finaleinzug' };
      }
      if (participantCount <= 8) {
        return { stage: 'Viertelfinale', placement: 'Spiel um Halbfinaleinzug' };
      }
      if (participantCount <= 16) {
        return { stage: 'Achtelfinale', placement: 'Spiel um Viertelfinaleinzug' };
      }
      if (participantCount <= 32) {
        return { stage: 'Sechzehntelfinale', placement: 'Spiel um Achtelfinaleinzug' };
      }
      return { stage: 'K.-o.-Runde', placement: 'K.-o.-Phase' };
    };

    const applyModeState = () => {
      modeInputs.forEach((input) => {
        if (input.value === 'doubles') {
          const disableDoubles = state.participants.length < 4;
          input.disabled = disableDoubles;
          if (disableDoubles && state.mode === 'doubles') {
            state.mode = 'singles';
          }
        }
        input.checked = input.value === state.mode;
        const label = input.parentElement;
        label.classList.toggle('active', input.checked);
        label.classList.toggle('disabled', input.disabled);
      });
    };

    modeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (input.disabled) {
          return;
        }
        state.mode = input.value;
        applyModeState();
        updateStatus();
      });
    });

    const ensureTimer = (matchId) => {
      if (!matchTimers.has(matchId)) {
        matchTimers.set(matchId, {
          elapsed: 0,
          running: false,
          lastStart: null,
          intervalId: null
        });
      }
      return matchTimers.get(matchId);
    };

    const formatTime = (ms) => {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
      const seconds = (totalSeconds % 60).toString().padStart(2, '0');
      const millis = Math.floor(ms % 1000).toString().padStart(3, '0');
      return `${minutes}:${seconds}.${millis}`;
    };

    const updateTimerDisplay = (matchId) => {
      const timer = matchTimers.get(matchId);
      if (!timer) {
        return;
      }
      let total = timer.elapsed;
      if (timer.running && timer.lastStart !== null) {
        total += Date.now() - timer.lastStart;
      }

      const display = document.getElementById(`timer-display-${matchId}`);
      if (display) {
        display.textContent = formatTime(total);
      }

      const startBtn = document.getElementById(`timer-start-${matchId}`);
      const stopBtn = document.getElementById(`timer-stop-${matchId}`);
      const hasTime = total > 0;

      if (startBtn) {
        const label = !timer.running && hasTime ? 'Weiter' : 'Start';
        startBtn.textContent = label;
        startBtn.disabled = timer.running;
      }
      if (stopBtn) {
        const canStop = timer.running || hasTime;
        stopBtn.disabled = !canStop;
      }
    };

    const startTimer = (matchId) => {
      const timer = ensureTimer(matchId);
      if (timer.running) {
        return;
      }
      timer.running = true;
      timer.lastStart = Date.now();
      if (timer.intervalId) {
        clearInterval(timer.intervalId);
      }
      timer.intervalId = setInterval(() => updateTimerDisplay(matchId), 50);
      updateTimerDisplay(matchId);
    };

    const stopTimer = (matchId) => {
      const timer = matchTimers.get(matchId);
      if (!timer) {
        return;
      }
      if (timer.running) {
        timer.elapsed += Date.now() - timer.lastStart;
        timer.running = false;
        timer.lastStart = null;
      } else {
        timer.elapsed = 0;
      }
      if (timer.intervalId) {
        clearInterval(timer.intervalId);
        timer.intervalId = null;
      }
      updateTimerDisplay(matchId);
    };

    const clearTimer = (matchId) => {
      const timer = matchTimers.get(matchId);
      if (!timer) {
        return;
      }
      if (timer.intervalId) {
        clearInterval(timer.intervalId);
        timer.intervalId = null;
      }
      matchTimers.delete(matchId);
    };

    const clearAllTimers = () => {
      Array.from(matchTimers.keys()).forEach((id) => clearTimer(id));
    };

    const createParticipant = (label, members = null) => ({
      id: nextId++,
      label,
      members: members || [label],
      type: members && members.length > 1 ? 'team' : 'player'
    });

    const shuffle = (array) => {
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    };

    const renderParticipants = () => {
      playerList.innerHTML = '';
      if (!state.participants.length) {
        const li = document.createElement('li');
        li.textContent = 'Noch keine Spieler hinzugefügt.';
        playerList.appendChild(li);
        return;
      }

      state.participants.forEach((participant) => {
        const li = document.createElement('li');
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = participant.label;
        li.appendChild(label);

        const info = document.createElement('span');
        info.className = 'tag';
        info.textContent = participant.members.length > 1 ? 'Team' : 'Spieler';
        li.appendChild(info);

        if (participant.type === 'player' && !state.currentRound) {
          const removeBtn = document.createElement('button');
          removeBtn.className = 'secondary';
          removeBtn.style.marginLeft = '0.8rem';
          removeBtn.textContent = 'Entfernen';
          removeBtn.addEventListener('click', () => removeParticipant(participant.id));
          li.appendChild(removeBtn);
        }

        playerList.appendChild(li);
      });
    };

    const updateStatus = () => {
      applyModeState();
      const modeLabel = state.mode === 'singles' ? 'Einzel' : 'Doppel';
      roundStatus.textContent = `Aktuelle Teilnehmer: ${state.participants.length} – Modus: ${modeLabel}`;
      const required = state.mode === 'doubles' ? 4 : 2;
      const hasEnoughParticipants = state.participants.length >= required;
      startRoundBtn.disabled = state.matches.length > 0 || !hasEnoughParticipants;
    };

    const renderMatches = () => {
      matchesContainer.innerHTML = '';
      submitWrapper.style.display = state.matches.length ? 'flex' : 'none';
      if (state.bye.length) {
        const names = state.bye.map((participant) => participant.label).join(', ');
        byeInfo.innerHTML = `<p><strong>Freilose:</strong> ${names} rücken automatisch in die nächste Runde vor.</p>`;
      } else {
        byeInfo.innerHTML = '';
      }

      if (!state.matches.length) {
        matchesContainer.innerHTML = `
          <div class="empty-state">
            <strong>Keine aktiven Matches</strong>
            <span>Starte eine neue Runde, um Begegnungen zu erstellen.</span>
          </div>
        `;
        return;
      }

      state.matches.forEach((match, index) => {
        const fieldset = document.createElement('fieldset');
        fieldset.className = 'match';
        const legend = document.createElement('legend');
        legend.textContent = `Match ${index + 1} – ${match.type === 'doubles' ? 'Doppel' : 'Einzel'}`;
        fieldset.appendChild(legend);

        if (match.meta) {
          const metaRow = document.createElement('div');
          metaRow.className = 'match-meta';

          if (match.meta.stage) {
            const stageBadge = document.createElement('span');
            stageBadge.className = 'badge stage';
            stageBadge.textContent = match.meta.stage;
            metaRow.appendChild(stageBadge);
          }

          if (match.meta.placement) {
            const placementBadge = document.createElement('span');
            placementBadge.className = 'badge placement';
            placementBadge.textContent = match.meta.placement;
            metaRow.appendChild(placementBadge);
          }

          if (metaRow.children.length) {
            fieldset.appendChild(metaRow);
          }
        }

        match.options.forEach((option, optionIndex) => {
          const label = document.createElement('label');
          label.className = 'option';
          const radio = document.createElement('input');
          radio.type = 'radio';
          radio.name = `match-${match.id}`;
          radio.value = optionIndex;
          label.appendChild(radio);

          const text = document.createElement('span');
          text.textContent = option.label;
          label.appendChild(text);

          fieldset.appendChild(label);
        });

        ensureTimer(match.id);

        const timerWrapper = document.createElement('div');
        timerWrapper.className = 'timer';

        const timerLabel = document.createElement('span');
        timerLabel.textContent = 'Spielzeit:';
        timerWrapper.appendChild(timerLabel);

        const timerDisplay = document.createElement('span');
        timerDisplay.className = 'timer-display';
        timerDisplay.id = `timer-display-${match.id}`;
        timerWrapper.appendChild(timerDisplay);

        const timerControls = document.createElement('div');
        timerControls.className = 'timer-controls';

        const startBtn = document.createElement('button');
        startBtn.type = 'button';
        startBtn.className = 'small';
        startBtn.id = `timer-start-${match.id}`;
        startBtn.textContent = 'Start';
        startBtn.addEventListener('click', () => startTimer(match.id));
        timerControls.appendChild(startBtn);

        const stopBtn = document.createElement('button');
        stopBtn.type = 'button';
        stopBtn.className = 'small secondary';
        stopBtn.id = `timer-stop-${match.id}`;
        stopBtn.textContent = 'Stop';
        stopBtn.addEventListener('click', () => stopTimer(match.id));
        timerControls.appendChild(stopBtn);

        timerWrapper.appendChild(timerControls);
        fieldset.appendChild(timerWrapper);

        const scoreWrapper = document.createElement('div');
        scoreWrapper.className = 'score-input';
        const scoreLabel = document.createElement('label');
        scoreLabel.textContent = 'Ergebnis (z. B. 6:4, 4:6, 10:8)';
        const scoreInput = document.createElement('input');
        scoreInput.type = 'text';
        scoreInput.name = `score-${match.id}`;
        scoreWrapper.appendChild(scoreLabel);
        scoreWrapper.appendChild(scoreInput);
        fieldset.appendChild(scoreWrapper);

        matchesContainer.appendChild(fieldset);
        updateTimerDisplay(match.id);
      });
    };

    const renderHistory = () => {
      historyContainer.innerHTML = '';
      if (!state.history.length) {
        const empty = document.createElement('p');
        empty.textContent = 'Noch keine Runden gespielt.';
        historyContainer.appendChild(empty);
        return;
      }

      state.history.forEach((round) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'history-round';
        const title = document.createElement('h3');
        title.textContent = `Runde ${round.number}`;
        wrapper.appendChild(title);

        round.matches.forEach((match, index) => {
          const matchBlock = document.createElement('div');
          matchBlock.className = 'history-match';

          if (match.stage || match.placement) {
            const metaRow = document.createElement('div');
            metaRow.className = 'match-meta';

            if (match.stage) {
              const stageBadge = document.createElement('span');
              stageBadge.className = 'badge stage';
              stageBadge.textContent = match.stage;
              metaRow.appendChild(stageBadge);
            }

            if (match.placement) {
              const placementBadge = document.createElement('span');
              placementBadge.className = 'badge placement';
              placementBadge.textContent = match.placement;
              metaRow.appendChild(placementBadge);
            }

            if (metaRow.children.length) {
              matchBlock.appendChild(metaRow);
            }
          }

          const p = document.createElement('p');
          const vs = match.type === 'doubles' ? 'vs.' : 'gegen';
          const contestants = match.type === 'doubles'
            ? `${match.teams[0]} ${vs} ${match.teams[1]}`
            : `${match.players[0]} ${vs} ${match.players[1]}`;
          const scoreText = match.score ? ` – Ergebnis: ${match.score}` : '';
          p.innerHTML = `<strong>Match ${index + 1}:</strong> ${contestants}<br><span class="tag">Sieger: ${match.winner}</span>${scoreText}`;
          matchBlock.appendChild(p);

          wrapper.appendChild(matchBlock);
        });

        if (round.byes && round.byes.length) {
          const bye = document.createElement('p');
          bye.className = 'bye';
          bye.textContent = `${round.byes.join(', ')} ${round.byes.length === 1 ? 'war' : 'waren'} in dieser Runde spielfrei.`;
          wrapper.appendChild(bye);
        }

        historyContainer.appendChild(wrapper);
      });
    };

    const renderChampion = () => {
      if (state.participants.length === 1 && !state.matches.length && state.currentRound > 0) {
        const winner = state.participants[0];
        champion.innerHTML = `
          <h3>Champion</h3>
          <p><strong>${winner.label}</strong> gewinnt das Turnier!</p>
        `;
      } else {
        champion.innerHTML = '';
      }
    };

    const removeParticipant = (id) => {
      state.participants = state.participants.filter((participant) => participant.id !== id);
      renderParticipants();
      updateStatus();
    };

    const resetTournament = () => {
      state.participants = [];
      state.currentRound = 0;
      state.matches = [];
      state.bye = [];
      state.history = [];
      state.mode = 'singles';
      nextId = 1;
      clearAllTimers();
      champion.innerHTML = '';
      applyModeState();
      renderParticipants();
      updateStatus();
      renderMatches();
      renderHistory();
    };

    const createMatchOptions = (participants) => {
      const options = [];
      const teams = [];
      for (let i = 0; i < participants.length; i += 2) {
        const teamMembers = [participants[i], participants[i + 1]];
        options.push({
          label: `${teamMembers[0].label} & ${teamMembers[1].label}`,
          members: [...teamMembers[0].members, ...teamMembers[1].members]
        });
        teams.push(`${teamMembers[0].label} & ${teamMembers[1].label}`);
      }
      return { options, teams };
    };

    const startRound = () => {
      if (state.matches.length) {
        alert('Bitte beende zuerst die aktuelle Runde.');
        return;
      }

      const mode = state.mode;
      const minimum = mode === 'doubles' ? 4 : 2;
      if (state.participants.length < minimum) {
        alert(mode === 'doubles'
          ? 'Für eine Doppelrunde werden mindestens vier Spieler benötigt.'
          : 'Mindestens zwei Teilnehmer werden benötigt.');
        return;
      }

      clearAllTimers();

      const pool = state.participants.map((participant) => ({
        ...participant,
        members: [...participant.members]
      }));
      shuffle(pool);

      const matches = [];
      const byeList = [];
      const stageInfo = getStageInfo(state.participants.length);

      if (mode === 'singles') {
        if (pool.length % 2 === 1) {
          byeList.push(pool.pop());
        }
        while (pool.length >= 2) {
          const p1 = pool.pop();
          const p2 = pool.pop();
          matches.push({
            id: `${state.currentRound + 1}-${matches.length + 1}`,
            type: 'singles',
            options: [
              { label: p1.label, members: [...p1.members] },
              { label: p2.label, members: [...p2.members] }
            ],
            detail: { players: [p1.label, p2.label] },
            meta: { ...stageInfo }
          });
        }
      } else {
        const remainder = pool.length % 4;
        if (remainder) {
          byeList.push(...pool.splice(-remainder));
        }
        while (pool.length >= 4) {
          const quartet = pool.splice(-4);
          const { options, teams } = createMatchOptions(quartet);
          matches.push({
            id: `${state.currentRound + 1}-${matches.length + 1}`,
            type: 'doubles',
            options,
            detail: { teams },
            meta: { ...stageInfo }
          });
        }
      }

      if (!matches.length) {
        alert('Es konnten keine Spiele für diese Runde erstellt werden.');
        return;
      }

      state.currentRound += 1;
      state.matches = matches;
      state.bye = byeList;
      renderMatches();
      updateStatus();
    };

    const processResults = (event) => {
      event.preventDefault();
      if (!state.matches.length) {
        return;
      }

      const winners = [];
      const roundSummary = {
        number: state.currentRound,
        matches: [],
        byes: state.bye.map((participant) => participant.label)
      };

      for (const match of state.matches) {
        const choice = matchesForm.querySelector(`input[name="match-${match.id}"]:checked`);
        if (!choice) {
          alert('Bitte wähle für jedes Match einen Sieger aus.');
          return;
        }
        const winnerIndex = Number(choice.value);
        const winnerOption = match.options[winnerIndex];
        const scoreInput = matchesForm.querySelector(`input[name="score-${match.id}"]`);
        const score = scoreInput.value.trim();

        if (match.type === 'doubles') {
          roundSummary.matches.push({
            type: 'doubles',
            teams: match.detail.teams,
            winner: winnerOption.label,
            score,
            stage: match.meta?.stage ?? null,
            placement: match.meta?.placement ?? null
          });
          winnerOption.members.forEach((memberName) => {
            winners.push(createParticipant(memberName, [memberName]));
          });
        } else {
          roundSummary.matches.push({
            type: 'singles',
            players: match.detail.players,
            winner: winnerOption.label,
            score,
            stage: match.meta?.stage ?? null,
            placement: match.meta?.placement ?? null
          });
          winners.push(createParticipant(winnerOption.label, [...winnerOption.members]));
        }

      }

      if (state.bye.length) {
        winners.push(...state.bye);
      }

      state.history.push(roundSummary);
      state.participants = winners;
      state.matches = [];
      state.bye = [];
      clearAllTimers();

      renderParticipants();
      updateStatus();
      renderMatches();
      renderHistory();
      renderChampion();
    };

    playerForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const name = playerInput.value.trim();
      if (!name) {
        return;
      }
      state.participants.push(createParticipant(name));
      playerInput.value = '';
      renderParticipants();
      updateStatus();
    });

    startRoundBtn.addEventListener('click', startRound);
    matchesForm.addEventListener('submit', processResults);
    resetBtn.addEventListener('click', () => {
      if (confirm('Turnier wirklich zurücksetzen?')) {
        resetTournament();
      }
    });

    renderParticipants();
    updateStatus();
    renderMatches();
    renderHistory();
  </script>
</body>

</html>
